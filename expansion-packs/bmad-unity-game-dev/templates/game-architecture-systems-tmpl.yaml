template:
  id: game-architecture-systems-template-v2
  name: Game Architecture Systems Document
  version: 2.0
  output:
    format: markdown
    filename: docs/game-architecture-systems.md
    title: "{{project_name}} Game Systems Architecture"

workflow:
  mode: interactive
  elicitation: advanced-elicitation

sections:
  - id: introduction
    title: Game Systems Architecture Overview
    content: |
      This document defines the core game systems architecture for {{project_name}}. This is Part 2 of the multi-phase architecture design, focusing on gameplay systems, data models, and component interactions.

      This document builds upon the Foundation Architecture and should be used in conjunction with it. All technology choices and project structure decisions from the Foundation document are considered definitive.

  - id: data-models
    title: Game Data Models
    instruction: |
      Define the core game data models/entities using Unity's ScriptableObject system:

      1. Review GDD requirements and identify key game entities
      2. For each model, explain its purpose and relationships
      3. Include key attributes and data types appropriate for Unity/C#
      4. Show relationships between models using ScriptableObject references
      5. Discuss design decisions with user

      Create a clear conceptual model before moving to specific implementations.
    elicit: true
    repeatable: true
    sections:
      - id: model
        title: "{{model_name}}"
        template: |
          **Purpose:** {{model_purpose}}

          **Key Attributes:**
          - {{attribute_1}}: {{type_1}} - {{description_1}}
          - {{attribute_2}}: {{type_2}} - {{description_2}}

          **Relationships:**
          - {{relationship_1}}
          - {{relationship_2}}

          **ScriptableObject Implementation:**
          - Create as `[CreateAssetMenu]` ScriptableObject
          - Store in `Assets/_Project/Data/{{ModelName}}/`

  - id: components
    title: Core Component Architecture
    instruction: |
      Design the core Unity components (MonoBehaviours) that will drive the gameplay:

      1. Based on the GDD mechanics, identify key component types needed
      2. Define component responsibilities and interfaces
      3. Plan component composition and relationships
      4. Consider component reusability and inheritance patterns
      5. Address component communication and event handling

      Focus on creating a modular, testable component architecture.
    elicit: true
    repeatable: true
    sections:
      - id: component
        title: "{{component_name}}"
        template: |
          **Purpose:** {{component_purpose}}

          **Key Responsibilities:**
          - {{responsibility_1}}
          - {{responsibility_2}}
          - {{responsibility_3}}

          **Public Interface:**
          ```csharp
          {{interface_definition}}
          ```

          **Dependencies:**
          - {{dependency_1}}
          - {{dependency_2}}

          **Events/Communication:**
          - {{event_1}}: {{event_description_1}}
          - {{event_2}}: {{event_description_2}}

      [[LLM: Include Visual Scripting integration if the project involves non-programmer team members, designers who need to implement logic, or rapid prototyping workflows. Detect based on team composition or prototyping requirements mentioned.]]
      
      - id: visual-scripting-integration
        title: Visual Scripting Integration
        template: |
          **Visual Scripting Scope:** {{visual_scripting_scope}}
          
          **Script Graph Categories:**
          - {{graph_category_1}}: {{graph_purpose_1}}
          - {{graph_category_2}}: {{graph_purpose_2}}
          
          **C# Script Integration:**
          - Custom Nodes: {{custom_node_1}}, {{custom_node_2}}
          - Exposed Variables: {{exposed_var_1}}, {{exposed_var_2}}
          
          **Designer-Accessible Systems:**
          - {{designer_system_1}}: {{accessibility_level_1}}
          - {{designer_system_2}}: {{accessibility_level_2}}
          
          **Visual Script Organization:**
          - Graph Assets: `Assets/_Project/VisualScripts/{{category}}/`
          - Shared Variables: `Assets/_Project/VisualScripts/Variables/`
          
          **Workflow Integration:**
          - {{workflow_integration_1}}
          - {{workflow_integration_2}}

  - id: gameplay-systems
    title: Gameplay Systems
    instruction: |
      Define the major gameplay systems that orchestrate the game experience:

      1. Review GDD mechanics and identify core systems (movement, combat, progression, etc.)
      2. For each system, define its purpose, components, and data flow
      3. Show how systems interact and communicate
      4. Consider system initialization, update patterns, and lifecycle
      5. Plan for system scalability and performance

      These systems should coordinate the components and data models defined above.
    elicit: true
    repeatable: true
    sections:
      - id: system
        title: "{{system_name}} System"
        template: |
          **Purpose:** {{system_purpose}}

          **Core Components:**
          - {{component_1}}: {{component_role_1}}
          - {{component_2}}: {{component_role_2}}

          **Data Dependencies:**
          - {{data_dependency_1}}
          - {{data_dependency_2}}

          **System Flow:**
          1. {{flow_step_1}}
          2. {{flow_step_2}}
          3. {{flow_step_3}}

          **External Interactions:**
          - {{interaction_1}}
          - {{interaction_2}}

          **Performance Considerations:**
          - {{performance_note_1}}
          - {{performance_note_2}}

  - id: component-architecture
    title: Component Communication Architecture
    instruction: |
      Design how components communicate and coordinate within the Unity architecture:

      1. Define component discovery and reference patterns
      2. Plan event-driven communication vs direct references
      3. Consider Unity Events vs C# Events usage
      4. Design message passing and system coordination
      5. Plan for component lifecycle and cleanup

      Focus on loose coupling and testability while maintaining Unity patterns.
    elicit: true
    sections:
      - id: communication-patterns
        title: Communication Patterns
        template: |
          **Component References:**
          - {{reference_pattern_1}}
          - {{reference_pattern_2}}

          **Event Communication:**
          - {{event_pattern_1}}
          - {{event_pattern_2}}

          **Message Passing:**
          - {{message_pattern_1}}
          - {{message_pattern_2}}

          **System Coordination:**
          - {{coordination_pattern_1}}
          - {{coordination_pattern_2}}

  - id: state-machines
    title: State Management Architecture
    instruction: |
      Design state management systems for game entities and overall game flow:

      1. Identify entities that need state management (player, enemies, game flow, UI)
      2. Choose appropriate state machine patterns (enum-based, class-based, Unity Animator)
      3. Define state transitions and triggers
      4. Plan state persistence and serialization
      5. Consider debugging and visualization of state changes

      Align state management with Unity's preferred patterns and tools.
    elicit: true
    sections:
      - id: state-architecture
        title: State Management Architecture
        template: |
          **State Machine Pattern:** {{state_pattern_choice}}
          
          **Rationale:** {{pattern_rationale}}

          **Key State Machines:**
          - {{state_machine_1}}: {{states_1}}
          - {{state_machine_2}}: {{states_2}}

          **State Persistence:**
          - {{persistence_approach_1}}
          - {{persistence_approach_2}}

          **Debugging Tools:**
          - {{debug_tool_1}}
          - {{debug_tool_2}}

  - id: physics-config
    title: Physics Configuration
    instruction: |
      [[LLM: Enhance physics configuration based on detected gameplay mechanics. Include advanced physics features if complex interactions, realistic simulations, or physics-based puzzles are mentioned. Scale complexity based on game requirements.]]
      
      Configure Unity's physics system for the game's requirements:

      1. Review GDD mechanics for physics complexity and requirements
      2. Configure physics layers, collision matrix, and performance settings
      3. Design physics materials and interaction behaviors  
      4. Plan advanced physics features if needed (joints, effectors, custom physics)
      5. Optimize physics performance for target platforms

      [[LLM: For simple games, focus on basic collision detection and layers. For physics-based games, include advanced features like joints, effectors, and complex materials.]]
    elicit: true
    sections:
      - id: physics-layers
        title: Physics Layers Configuration
        type: table
        columns: [Layer Name, Layer ID, Purpose, Collision Matrix, Performance Notes]
        instruction: Define all physics layers needed for the game
        examples:
          - "| Player | 8 | Player character collision | Collides with: Ground, Enemies, Pickups | High priority, optimized shapes |"
          - "| Enemy | 9 | Enemy collision detection | Collides with: Player, Ground, Projectiles | Medium priority, compound colliders |"
          - "| Ground | 10 | Static environment collision | Collides with: All dynamic objects | Static optimization enabled |"
      - id: physics-materials
        title: Physics Materials & Interactions
        template: |
          **Material Definitions:**
          - {{material_1}}: Friction {{friction_1}}, Bounciness {{bounce_1}} - {{material_purpose_1}}
          - {{material_2}}: Friction {{friction_2}}, Bounciness {{bounce_2}} - {{material_purpose_2}}

          **Interaction Behaviors:**
          - {{interaction_1}}: {{interaction_description_1}}
          - {{interaction_2}}: {{interaction_description_2}}

          **Performance Optimization:**
          - Fixed Timestep: {{physics_timestep}}
          - Solver Iterations: {{solver_iterations}}
          - Contact Processing: {{contact_processing_optimization}}

      - id: advanced-physics
        title: Advanced Physics Features
        conditional: has_complex_physics || needs_realistic_simulation
        template: |
          [[LLM: Only include if complex physics interactions, realistic simulations, physics-based puzzles, or advanced mechanical systems are required]]
          
          **Physics Joints & Constraints:**
          - {{joint_type_1}}: {{joint_purpose_1}} - {{joint_configuration_1}}
          - {{joint_type_2}}: {{joint_purpose_2}} - {{joint_configuration_2}}

          **Physics Effectors (2D):**
          - {{effector_type_1}}: {{effector_application_1}}
          - {{effector_type_2}}: {{effector_application_2}}

          **Custom Physics Behaviors:**
          - {{custom_behavior_1}}: {{behavior_implementation_1}}
          - {{custom_behavior_2}}: {{behavior_implementation_2}}

          **Advanced Optimization:**
          - LOD Physics: {{physics_lod_strategy}}
          - Predictive Systems: {{physics_prediction}}
          - Multi-threading: {{physics_threading_approach}}

  - id: input-system
    title: Input System Architecture
    instruction: |
      Design the input handling system using Unity's Input System:

      1. Review GDD for input requirements (controls, platforms, accessibility)
      2. Define input actions and control schemes
      3. Plan input handling across different game states
      4. Design input buffering and responsiveness systems
      5. Consider platform-specific input requirements

      Use Unity's modern Input System for flexible, rebindable controls.
    elicit: true
    sections:
      - id: input-actions
        title: Input Actions Configuration
        template: |
          **Control Schemes:**
          - {{control_scheme_1}}: {{devices_1}}
          - {{control_scheme_2}}: {{devices_2}}

          **Input Actions:**
          - {{action_1}}: {{action_description_1}}
          - {{action_2}}: {{action_description_2}}

          **Input Processing:**
          - {{processing_rule_1}}
          - {{processing_rule_2}}
      - id: input-handling
        title: Input Handling Architecture
        template: |
          **Input Managers:**
          - {{manager_1}}: {{manager_responsibility_1}}
          - {{manager_2}}: {{manager_responsibility_2}}

          **State-Based Input:**
          - {{state_input_1}}
          - {{state_input_2}}

          **Input Buffering:**
          - {{buffer_system_1}}
          - {{buffer_system_2}}

  - id: scene-management
    title: Scene Management Architecture
    instruction: |
      Design the scene loading and management system:

      1. Plan scene organization and loading strategy
      2. Define scene transition patterns and loading screens
      3. Design persistent data handling across scenes
      4. Plan additive scene loading for complex levels
      5. Consider memory management and performance

      Align scene management with game flow and technical requirements.
    elicit: true
    sections:
      - id: scene-organization
        title: Scene Organization
        template: |
          **Scene Categories:**
          - {{scene_category_1}}: {{category_purpose_1}}
          - {{scene_category_2}}: {{category_purpose_2}}

          **Loading Strategy:**
          - {{loading_strategy_1}}
          - {{loading_strategy_2}}

          **Transition Patterns:**
          - {{transition_1}}: {{transition_description_1}}
          - {{transition_2}}: {{transition_description_2}}
      - id: persistent-data
        title: Cross-Scene Data Management
        template: |
          **Persistent Managers:**
          - {{manager_1}}: {{persistence_scope_1}}
          - {{manager_2}}: {{persistence_scope_2}}

          **Data Preservation:**
          - {{preservation_method_1}}
          - {{preservation_method_2}}

          **Scene Initialization:**
          - {{init_pattern_1}}
          - {{init_pattern_2}}

  - id: cinemachine-cameras
    title: Cinemachine Camera System
    instruction: |
      [[LLM: Include this section if the game requires dynamic cameras, camera following, smooth transitions, or complex camera behaviors. Auto-detect 2D vs 3D requirements and provide appropriate camera configurations.]]
      
      Design Cinemachine virtual camera system for dynamic camera management:

      1. Identify camera requirements from gameplay mechanics
      2. Plan virtual camera hierarchy and priorities
      3. Configure camera blending and transitions
      4. Design camera constraints and behaviors
      5. Optimize for target platform performance

      [[LLM: For 2D games, emphasize pixel-perfect cameras, orthographic setups, confiner and follow components. For 3D games, focus on free-look cameras, orbital cameras, and cinematic camera movements.]]
    elicit: true
    conditional: needs_dynamic_cameras || has_character_following || has_camera_transitions
    sections:
      - id: virtual-camera-setup
        title: Virtual Camera Configuration
        template: |
          **Camera Hierarchy:**
          - {{camera_type_1}}: Priority {{priority_1}} - {{camera_purpose_1}}
          - {{camera_type_2}}: Priority {{priority_2}} - {{camera_purpose_2}}
          
          **Brain Configuration:**
          - Default Blend: {{default_blend_type}} ({{blend_duration}}s)
          - Custom Blends: {{custom_blend_1}}
          
          **2D Camera Components** (if applicable):
          - Pixel Perfect Camera: {{pixel_perfect_settings}}
          - 2D Confiner: {{confiner_configuration}}
          - 2D Follow: {{follow_settings_2d}}
          
          **3D Camera Components** (if applicable):
          - Free Look: {{freelook_configuration}}
          - Orbital Transposer: {{orbital_settings}}
          - Third Person Follow: {{third_person_settings}}
          
          **Performance Optimization:**
          - {{optimization_1}}
          - {{optimization_2}}

  - id: timeline-cinematics
    title: Timeline & Cinematics System
    instruction: |
      [[LLM: Only include this section if the game requires cutscenes, cinematics, complex animations, or narrative sequences. Detect based on user responses about story elements, character interactions, or cinematic presentation needs.]]
      
      Design Unity Timeline integration for cinematic sequences and complex animations:

      1. Review GDD for cinematic requirements (cutscenes, character interactions, story beats)
      2. Plan Timeline asset organization and track types needed
      3. Design integration with Cinemachine for camera choreography
      4. Consider Timeline Signals for gameplay integration
      5. Plan for both 2D and 3D cinematic approaches

      [[LLM: For 2D games, focus on sprite-based cinematics, UI animations, and orthographic camera movements. For 3D games, emphasize virtual cameras, 3D character animation, and environmental storytelling.]]
    elicit: true
    conditional: has_cinematics || has_cutscenes || has_narrative_sequences
    sections:
      - id: timeline-architecture
        title: Timeline System Architecture
        template: |
          **Timeline Organization Strategy:** {{timeline_organization}}
          
          **Primary Track Types:**
          - {{track_type_1}}: {{track_purpose_1}}
          - {{track_type_2}}: {{track_purpose_2}}
          
          **Cinemachine Integration:**
          - {{cinemachine_integration_1}}
          - {{cinemachine_integration_2}}
          
          **Timeline Signals & Events:**
          - {{signal_1}}: {{signal_trigger_1}}
          - {{signal_2}}: {{signal_trigger_2}}
          
          **Asset Organization:**
          - Timeline Assets: `Assets/_Project/Timelines/{{timeline_category}}/`
          - Playable Assets: `Assets/_Project/Timelines/Playables/`
          
          **2D/3D Considerations:**
          - {{dimension_consideration_1}}
          - {{dimension_consideration_2}}

  - id: data-persistence
    title: Data Persistence Architecture
    instruction: |
      Design the save/load system and data persistence strategy:

      1. Identify what game data needs to be persisted
      2. Choose serialization format and storage location
      3. Design save file structure and versioning
      4. Plan auto-save and checkpoint systems
      5. Consider cloud save integration if needed

      Focus on reliable, maintainable save systems that handle edge cases.
    elicit: true
    sections:
      - id: save-data-structure
        title: Save Data Structure
        template: |
          **Save File Format:** {{save_format}}

          **Data Categories:**
          - {{data_category_1}}: {{category_content_1}}
          - {{data_category_2}}: {{category_content_2}}

          **Versioning Strategy:**
          - {{versioning_approach}}
          - {{migration_strategy}}

          **Storage Location:**
          - {{storage_location_1}}: {{location_purpose_1}}
          - {{storage_location_2}}: {{location_purpose_2}}
      - id: save-load-flow
        title: Save/Load Flow
        template: |
          **Save Triggers:**
          - {{save_trigger_1}}: {{trigger_description_1}}
          - {{save_trigger_2}}: {{trigger_description_2}}

          **Load Process:**
          1. {{load_step_1}}
          2. {{load_step_2}}
          3. {{load_step_3}}

          **Error Handling:**
          - {{error_case_1}}: {{error_handling_1}}
          - {{error_case_2}}: {{error_handling_2}}

  - id: unity-gaming-services
    title: Unity Gaming Services Integration
    instruction: |
      [[LLM: Conditionally include Gaming Services based on detected requirements. Include Authentication if multiplayer or social features exist. Include Cloud Save if progression systems are mentioned. Include Analytics if monetization or player behavior tracking is needed. Include Remote Config if live operations or A/B testing requirements are identified.]]
      
      Design intelligent Unity Gaming Services integration:

      1. Analyze project requirements for cloud services needs
      2. Identify required UGS services based on game features and monetization model
      3. Plan service initialization, dependency management, and graceful degradation
      4. Design privacy compliance and consent management
      5. Configure service integration with offline fallbacks

      [[LLM: Only include services sections that match detected project requirements. For single-player offline games, consider minimal analytics only.]]
    elicit: true
    conditional: needs_cloud_features || has_progression || needs_analytics || has_live_ops
    sections:
      - id: ugs-authentication
        title: Authentication Services
        conditional: has_multiplayer || has_social_features || needs_cloud_save
        template: |
          [[LLM: Only include if multiplayer, social features, or cloud save requirements detected]]
          
          **Authentication Strategy:** {{auth_strategy}}
          **Primary Provider:** {{auth_provider}}
          
          **Sign-in Methods:**
          - {{signin_method_1}}: {{method_priority_1}} - {{method_description_1}}
          - {{signin_method_2}}: {{method_priority_2}} - {{method_description_2}}

          **Anonymous Authentication:** {{anonymous_support}}
          **Account Linking:** {{account_linking_strategy}}
          
          **Privacy & Consent:**
          - GDPR Compliance: {{gdpr_implementation}}
          - Data Processing Consent: {{consent_management}}
      - id: ugs-cloud-save
        title: Cloud Save Integration  
        conditional: has_progression || needs_cross_platform
        template: |
          [[LLM: Only include if progression systems, cross-platform play, or user data persistence requirements detected]]
          
          **Cloud Save Scope:** {{cloud_save_scope}}
          
          **Data Synchronization:**
          - {{sync_data_1}}: Priority {{sync_priority_1}} - {{sync_frequency_1}}
          - {{sync_data_2}}: Priority {{sync_priority_2}} - {{sync_frequency_2}}

          **Conflict Resolution Strategy:** {{conflict_resolution}}
          **Offline/Online Coordination:** {{offline_coordination}}
          
          **Data Structure:**
          - Save Format: {{save_format}}
          - Versioning: {{save_versioning}}
          - Encryption: {{save_encryption}}
      - id: ugs-analytics
        title: Analytics Integration
        conditional: needs_player_insights || has_monetization || needs_optimization
        template: |
          [[LLM: Include if monetization, player behavior analysis, game balancing, or performance optimization requirements detected]]
          
          **Analytics Strategy:** {{analytics_strategy}}
          
          **Core Event Categories:**
          - {{event_category_1}}: {{event_examples_1}}
          - {{event_category_2}}: {{event_examples_2}}

          **Key Performance Indicators:**
          - {{kpi_1}}: {{kpi_measurement_1}}
          - {{kpi_2}}: {{kpi_measurement_2}}

          **Custom Parameters:**
          - {{custom_param_1}}: {{param_purpose_1}}
          - {{custom_param_2}}: {{param_purpose_2}}

          **Privacy Compliance:**
          - Data Retention: {{data_retention_policy}}
          - User Consent: {{analytics_consent_method}}
      - id: ugs-remote-config
        title: Remote Configuration
        conditional: has_live_ops || needs_ab_testing || has_monetization
        template: |
          [[LLM: Include if live operations, A/B testing, balancing updates, or monetization optimization requirements detected]]
          
          **Configuration Strategy:** {{remote_config_strategy}}
          
          **Configuration Categories:**
          - {{config_category_1}}: {{config_items_1}}
          - {{config_category_2}}: {{config_items_2}}

          **Update & Deployment:**
          - Update Frequency: {{update_frequency}}
          - Rollout Strategy: {{rollout_strategy}}
          - Rollback Procedures: {{rollback_procedures}}

          **A/B Testing Framework:**
          - {{ab_test_1}}: {{test_hypothesis_1}}
          - {{ab_test_2}}: {{test_hypothesis_2}}

          **Fallback Values:**
          - {{fallback_strategy_1}}
          - {{fallback_strategy_2}}

  - id: multiplayer-architecture
    title: Multiplayer Architecture
    instruction: |
      [[LLM: Include this section if the game has any multiplayer features including: cooperative play, competitive multiplayer, shared worlds, social features, leaderboards, or online functionality. Detect networking requirements from gameplay mechanics, player interaction descriptions, or social features mentioned.]]
      
      Design comprehensive multiplayer architecture using Unity's networking solutions:

      1. Analyze multiplayer scope and player interaction patterns
      2. Choose appropriate networking solution based on requirements
      3. Design network topology, authority model, and state synchronization
      4. Plan matchmaking, lobbies, and session management
      5. Consider platform-specific multiplayer requirements (Steam, console networks)
      6. Design offline fallbacks and network error handling

      [[LLM: For simple co-op or local multiplayer, suggest Unity Input System multi-device setup. For online multiplayer, recommend Netcode for GameObjects for Unity-native solution or evaluate third-party options based on complexity.]]
    elicit: true
    conditional: has_multiplayer || has_coop || has_online_features || has_social_features
    sections:
      - id: networking-foundation
        title: Networking Foundation
        template: |
          **Networking Solution:** {{networking_choice}}
          **Selection Rationale:** {{networking_rationale}}
          
          **Network Topology:** {{topology_type}}
          **Authority Model:** {{authority_model}}
          **Connection Model:** {{connection_model}}

          **Player Capacity & Sessions:**
          - Max Players: {{max_players}}
          - Session Duration: {{session_duration}}
          - Join-in-Progress: {{join_in_progress_support}}

          **Platform Integration:**
          - {{platform_1}}: {{platform_networking_1}}
          - {{platform_2}}: {{platform_networking_2}}

      - id: state-synchronization
        title: Advanced State Synchronization
        template: |
          **Synchronization Strategy:**
          - High Priority Objects: {{high_priority_sync}}
          - Medium Priority Objects: {{medium_priority_sync}}
          - Low Priority Objects: {{low_priority_sync}}

          **Client Prediction & Reconciliation:**
          - Prediction Systems: {{prediction_systems}}
          - Rollback Implementation: {{rollback_approach}}
          - Lag Compensation: {{lag_compensation_method}}

          **Anti-Cheat Considerations:**
          - Server Authority: {{server_authority_scope}}
          - Validation Systems: {{validation_systems}}
          - Monitoring: {{anti_cheat_monitoring}}

      - id: social-features
        title: Social & Matchmaking Systems
        template: |
          **Matchmaking Criteria:**
          - {{criteria_1}}: Weight {{weight_1}} - {{criteria_description_1}}
          - {{criteria_2}}: Weight {{weight_2}} - {{criteria_description_2}}

          **Social Features:**
          - {{social_feature_1}}: {{feature_implementation_1}}
          - {{social_feature_2}}: {{feature_implementation_2}}

          **Session Management:**
          - Session Types: {{session_types}}
          - Migration Strategy: {{host_migration_strategy}}
          - Reconnection Policy: {{reconnection_policy}}

  - id: next-steps
    title: Next Steps
    content: |
      This systems architecture document defines the core gameplay systems and data models. The next phases of architecture design will build upon these systems:

      **Phase 3: Platform Architecture**
      - Platform-specific optimizations and configurations
      - Performance profiling and optimization strategies
      - Cross-platform compatibility and testing

      **Phase 4: Advanced Architecture**
      - Advanced Unity features and integrations
      - Scalability considerations and technical debt management
      - Production deployment and maintenance strategies

      The systems defined in this document should be implemented alongside the Foundation Architecture before proceeding to platform-specific optimizations.