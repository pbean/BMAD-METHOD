template:
  id: game-architecture-foundation-template-v2
  name: Game Architecture Foundation Document
  version: 2.0
  output:
    format: markdown
    filename: docs/game-architecture-foundation.md
    title: "{{project_name}} Game Architecture Foundation"

workflow:
  mode: interactive
  elicitation: advanced-elicitation

sections:
  - id: introduction
    title: Introduction
    instruction: |
      If available, review any provided relevant documents to gather all relevant context before beginning. At a minimum you should locate and review: Game Design Document (GDD), Technical Preferences. If these are not available, ask the user what docs will provide the basis for the game architecture.
    sections:
      - id: intro-content
        content: |
          This document outlines the foundational technical architecture for {{project_name}}, a {{ProjectDimension}} game built with Unity and C#. This is Part 1 of a multi-phase architecture design covering Unity setup, core infrastructure, and project organization.

          This foundation architecture is designed to support the gameplay mechanics defined in the Game Design Document while establishing solid technical groundwork for subsequent architectural phases.
      
      - id: unity-version-analysis
        title: Unity Version Selection
        instruction: |
          [[LLM: Unity Version Intelligence]]
          Before proceeding with architecture design, analyze the project requirements and recommend the most appropriate Unity version:
          
          1. **Project Analysis:**
             - Review GDD for performance requirements, target platforms, and complexity
             - Consider team experience level and development timeline
             - Evaluate need for cutting-edge features vs stability
          
          2. **Version Recommendation Logic:**
             - LTS (Long Term Support): Recommend for production games, teams prioritizing stability, mobile/console targets
             - Tech Stream: Recommend for experimental projects, early adopters, or projects requiring newest features
             - Check Unity roadmap for feature alignment with project needs
          
          3. **Specific Evaluation Criteria:**
             - Mobile games: Strongly favor LTS for better platform compatibility
             - VR/AR projects: May need Tech Stream for latest XR features
             - 2D games: LTS typically sufficient unless using newest 2D tools
             - 3D games with advanced rendering: Evaluate based on HDRP/URP requirements
             - Console development: LTS required for certification compatibility
          
          4. **Output Format:**
             - State recommended Unity version with specific build number
             - Provide 2-3 sentence rationale based on project characteristics
             - Note any version-specific considerations or limitations
             - Mention upgrade path if starting with older version
          
          Document the selected Unity version and rationale here before proceeding.
        elicit: true

      - id: starter-template
        title: Starter Template or Existing Project
        instruction: |
          [[LLM: Starter Template Detection & Analysis]]
          Before proceeding further with game architecture design, perform comprehensive starter template analysis:

          1. **Detection Phase:**
             - Review GDD and brainstorming brief for mentions of Unity templates (2D Core, 2D Mobile, 2D URP, etc.)
             - Look for existing Unity projects, Asset Store packages, or game frameworks
             - Check for references to previous game projects to be adapted
             - Identify any boilerplate or scaffolding tools mentioned

          2. **Template Analysis (if found):**
             - Analyze starter template architecture and patterns
             - Document pre-configured Unity version, render pipeline, and package dependencies
             - Identify built-in project structure, scripts, and organizational conventions
             - Note any architectural constraints or opinionated decisions in the template
             - Evaluate alignment with project requirements from GDD

          3. **Recommendation Logic:**
             - For greenfield projects without starter: Suggest appropriate Unity templates based on target platform and game type
             - For projects with starter: Validate template choice against project requirements
             - Consider benefits: faster setup, Unity best practices, package integration, community support
             - Note limitations: reduced flexibility, potential feature conflicts, learning curve

          4. **Integration Strategy:**
             - If using starter: Align architecture decisions with template patterns
             - Document how to extend or modify template structure for project needs
             - Plan migration path if template becomes limiting
             - Identify areas where template choices override normal architectural decisions

          Document the starter template decision and analysis here before proceeding. If none, state "N/A - Greenfield Unity Project".
        elicit: true

      - id: project-dimension-detection
        title: Project Dimension Analysis
        instruction: |
          [[LLM: 2D/3D Project Intelligence]]
          Analyze the project characteristics to determine optimal Unity configuration and feature set:

          1. **Dimension Classification:**
             - Pure 2D: Side-scrollers, top-down games, mobile puzzle games
             - 2.5D: 2D gameplay with 3D assets, isometric games, layered 2D environments
             - Pure 3D: First-person, third-person, fully 3D environments
             - Hybrid: Games switching between 2D and 3D modes

          2. **Unity Feature Implications:**
             - 2D Projects: Tilemap system, 2D Physics, 2D Lighting, Sprite Renderer optimization
             - 3D Projects: 3D Physics, advanced lighting, post-processing, terrain systems
             - 2.5D Projects: Mixed physics systems, camera management, depth sorting
             - Hybrid Projects: Scene management, performance optimization for mode switching

          3. **Technology Stack Adaptation:**
             - Render Pipeline: Built-in (2D simple), URP (2D/3D balanced), HDRP (3D advanced)
             - Physics: Box2D vs 3D Physics vs hybrid approach
             - Camera Systems: Orthographic vs Perspective vs dynamic switching
             - Asset Pipeline: 2D sprites vs 3D models vs mixed workflows

          4. **Performance Considerations:**
             - Mobile 2D: Sprite atlasing, draw call optimization, 2D batching
             - Mobile 3D: LOD systems, occlusion culling, texture compression
             - Desktop 2D: High-resolution assets, advanced 2D effects, large world streaming
             - Desktop 3D: Advanced rendering features, complex shaders, high polygon counts

          Based on GDD analysis, classify this project and document dimension-specific architectural decisions.
        elicit: true
      - id: changelog
        title: Change Log
        type: table
        columns: [Date, Version, Description, Author]
        instruction: Track document versions and changes

  - id: high-level-architecture
    title: High Level Architecture
    instruction: |
      This section contains multiple subsections that establish the foundation of the game architecture. Present all subsections together at once.
    elicit: true
    sections:
      - id: technical-summary
        title: Technical Summary
        instruction: |
          [[LLM: Architecture Summary Intelligence]]
          Generate a comprehensive technical summary that adapts to the project characteristics identified above:

          1. **Contextual Summary Generation:**
             - Reference Unity version selected and its capabilities
             - Incorporate 2D/3D dimension analysis results
             - Include starter template implications if applicable
             - Align with target platform requirements

          2. **Content Adaptation:**
             - 2D Projects: Emphasize component-based 2D systems, sprite management, 2D physics integration
             - 3D Projects: Focus on 3D rendering pipeline, complex scene management, 3D physics systems
             - Mobile Projects: Highlight performance optimization, battery efficiency, touch input systems
             - Desktop/Console: Emphasize advanced graphics, complex input systems, high-performance computing

          3. **Unity-Specific Architecture Patterns:**
             - Component composition over inheritance patterns
             - ScriptableObject data architecture
             - Unity Events vs C# Events decision rationale
             - Prefab workflow and asset organization
             - Scene management and loading strategies

          Provide a unified paragraph (3-5 sentences) that weaves together:
          - The game's overall architecture style adapted to Unity patterns
          - Key game systems and their Unity-specific relationships
          - Primary technology choices from version and dimension analysis
          - Core architectural patterns optimized for the detected project type
          - Reference back to GDD goals and how this Unity architecture specifically supports them
      - id: high-level-overview
        title: High Level Overview
        instruction: |
          Based on the GDD's Technical Assumptions section, describe:

          1. The main architectural style (component-based Unity architecture with MonoBehaviours)
          2. Repository structure decision from GDD (single Unity project vs multiple projects)
          3. Game system architecture (modular systems, manager singletons, data-driven design)
          4. Primary player interaction flow and core game loop
          5. Key architectural decisions and their rationale (render pipeline, input system, physics)
      - id: render-pipeline-selection
        title: Render Pipeline Configuration
        instruction: |
          [[LLM: Render Pipeline Intelligence]]
          Select and configure the optimal render pipeline based on project analysis:

          1. **Pipeline Analysis:**
             - Built-in Render Pipeline: Legacy, simple 2D games, basic 3D, broad compatibility
             - Universal Render Pipeline (URP): Modern 2D/3D games, mobile optimization, balanced features
             - High Definition Render Pipeline (HDRP): High-end 3D, desktop/console, advanced graphics

          2. **Selection Logic:**
             - 2D Games: URP for modern features and optimization, Built-in for simplicity
             - Mobile 3D: URP for performance optimization and battery efficiency
             - Desktop/Console 3D: URP for balanced approach, HDRP for cutting-edge graphics
             - VR/AR: URP for performance requirements
             - Web/WebGL: Built-in or URP (check compatibility)

          3. **Configuration Implications:**
             - Lighting system setup and optimization
             - Shader compatibility and upgrade requirements
             - Post-processing pipeline configuration
             - Performance profiling and optimization strategies
             - Asset creation workflow adaptation

          4. **Technical Specifications:**
             - Document specific render pipeline version
             - List required package dependencies
             - Note shader and material compatibility
             - Specify lighting model and setup requirements

          Based on the project dimension analysis and target platforms, select and document the render pipeline choice with rationale.

      - id: project-diagram
        title: High Level Project Diagram
        type: mermaid
        mermaid_type: graph
        instruction: |
          Create a Mermaid diagram that visualizes the Unity-specific game architecture:
          - Core Unity systems (Input, Physics, Rendering, Audio, UI)
          - MonoBehaviour managers and ScriptableObject data
          - Unity Events and C# event communication
          - Asset loading and management systems
          - Platform-specific service integrations
          - Player interaction points through Unity's input systems

      - id: architectural-patterns
        title: Architectural and Design Patterns
        instruction: |
          List the key high-level patterns that will guide the game architecture. For each pattern:

          1. Present 2-3 viable options if multiple exist
          2. Provide your recommendation with clear rationale
          3. Get user confirmation before finalizing
          4. These patterns should align with the GDD's technical assumptions and project goals

          Unity-specific patterns to consider:
          - Component patterns (MonoBehaviour composition, Component-based design, Interface segregation)
          - Data patterns (ScriptableObject configuration, Persistent data, Event-driven architecture)
          - Unity lifecycle patterns (Initialization order, Update optimization, Object pooling)
          - Asset management patterns (Prefab workflows, Asset bundling, Addressables)
          - Scene management patterns (Additive loading, Persistent scenes, State management)
        template: "- **{{pattern_name}}:** {{pattern_description}} - _Unity Rationale:_ {{unity_specific_rationale}}"
        examples:
          - "**Component-Based Architecture:** Using MonoBehaviour components with clear responsibilities - _Unity Rationale:_ Leverages Unity's native component system for reusability and inspector-friendly development"
          - "**ScriptableObject Data Architecture:** Using ScriptableObjects for game configuration and runtime data - _Unity Rationale:_ Enables data-driven design, easy balancing, and asset-based workflow integration"
          - "**Unity Events with C# Actions:** Hybrid event system using both Unity Events and C# delegates - _Unity Rationale:_ Unity Events for designer-configurable connections, C# Actions for performance-critical systems"

  - id: tech-stack
    title: Tech Stack
    instruction: |
      [[LLM: Platform-Aware Technology Stack Intelligence]]
      This is the DEFINITIVE technology selection section for the Unity game. Generate intelligent recommendations based on project analysis:

      1. **Intelligent Recommendation Logic:**
         - Adapt suggestions based on Unity version selected above
         - Consider 2D/3D project dimension for feature selection
         - Factor in target platform requirements and limitations
         - Account for starter template constraints if applicable
         - Reference team technical preferences when available

      2. **Unity Package Manager Integration:**
         - Recommend packages based on detected game requirements
         - Ensure version compatibility with selected Unity version
         - Consider package dependencies and conflicts
         - Prioritize packages with good Unity integration

      3. **Platform-Specific Optimizations:**
         - Mobile: Lightweight packages, performance-optimized choices
         - Desktop: Feature-rich options, development productivity tools
         - Console: Platform SDK requirements, certification considerations
         - Web: WebGL compatibility, size constraints

      4. **Technology Selection Process:**
         - For each category, present 2-3 viable options with pros/cons
         - Make clear recommendations based on project characteristics analysis
         - Get explicit user approval for each selection
         - Document exact versions (avoid "latest" - pin specific versions)
         - This table is the single source of truth for all subsequent architecture documents

      Key Unity-specific decisions to finalize:
      - Unity version and render pipeline (from analysis above)
      - Unity Package Manager packages and versions
      - Input system choice (Legacy vs New Input System)
      - Physics system configuration (2D vs 3D vs hybrid)
      - Audio system and middleware integration
      - Platform SDKs and Unity Services
      - Development and debugging tools
      - Testing framework and CI/CD integration

      Present the technology stack table with intelligent, context-aware recommendations.
    elicit: true
    sections:
      - id: platform-infrastructure
        title: Platform Infrastructure
        template: |
          - **Target Platforms:** {{target_platforms}}
          - **Primary Platform:** {{primary_platform}}
          - **Unity Services:** {{unity_services_list}}
          - **Distribution:** {{distribution_channels}}
      - id: technology-stack-table
        title: Technology Stack Table
        type: table
        columns: [Category, Technology, Version, Purpose, Rationale]
        instruction: |
          [[LLM: Technology Stack Validation]]
          Populate the technology stack table with intelligent, project-adapted recommendations:

          1. **Validation Logic:**
             - Ensure Unity version compatibility for all selected packages
             - Verify render pipeline support for graphics-related packages
             - Check platform compatibility for all target platforms
             - Validate package dependency compatibility

          2. **Intelligent Package Selection:**
             - 2D Projects: Include 2D-specific packages (2D Tilemap, 2D Animation, 2D Lights)
             - 3D Projects: Include 3D-specific packages (Cinemachine, Timeline, ProBuilder)
             - Mobile Projects: Prioritize performance and optimization packages
             - Multiplayer Games: Include Netcode or Mirror networking
             - VR/AR Projects: Include XR Foundation and platform-specific SDKs

          3. **Required Core Entries:**
             - Game Engine: Unity with selected version and rationale
             - Language: C# with version compatible with Unity version
             - Render Pipeline: Selected pipeline with version and rationale
             - Input System: Legacy or New based on project requirements
             - Physics: Unity 2D Physics, 3D Physics, or hybrid approach
             - Audio: Unity Audio or third-party middleware
             - Testing: Unity Test Framework with version

        examples:
          - "| **Game Engine** | Unity | 2022.3.21f1 LTS | Core development platform | LTS version provides stability for production, comprehensive 2D/3D toolset |"
          - "| **Language** | C# | 9.0 | Primary scripting language | Unity 2022.3 C# 9.0 support, strong typing, excellent tooling |"
          - "| **Render Pipeline** | Universal Render Pipeline (URP) | 14.0.10 | 2D/3D rendering optimization | Balanced 2D/3D performance, mobile-optimized, future-proof architecture |"
          - "| **Input System** | Unity Input System | 1.7.0 | Modern input handling | Cross-platform input, rebindable controls, touch and gamepad support |"
          - "| **Physics** | Unity 2D Physics | Built-in | 2D collision and physics | Integrated Box2D, optimized for 2D gameplay, sprite-based colliders |"
          - "| **Testing** | Unity Test Framework | 1.1.33 | Unit and integration testing | Built-in NUnit-based testing, play-mode and edit-mode support |"

  - id: unity-project-structure
    title: Unity Project Structure
    instruction: |
      Define the complete Unity project folder structure optimized for the detected project characteristics:

      1. **Project-Specific Structure:**
         - Adapt folder organization for 2D vs 3D asset types
         - Consider starter template structure if applicable
         - Plan for target platform asset organization
         - Include Unity Package Manager local packages if needed

      2. **Unity Best Practices Integration:**
         - Follow Unity naming conventions and folder hierarchy
         - Organize for team collaboration and asset management
         - Consider Unity version control best practices
         - Plan for editor tools and development utilities

      3. **Scalability Considerations:**
         - Structure that grows with project complexity
         - Separate concerns for better maintainability
         - Consider asset loading performance implications
         - Plan for localization and platform variants
    elicit: true
    sections:
      - id: folder-structure
        title: Project Folder Structure
        template: |
          ```
          Assets/
          ├── _Project/                    # Main project assets
          │   ├── Scripts/
          │   │   ├── {{script_categories}}
          │   ├── Prefabs/
          │   │   ├── {{prefab_categories}}
          │   ├── Scenes/
          │   │   ├── {{scene_categories}}
          │   ├── Data/
          │   │   ├── {{data_categories}}
          │   ├── Audio/
          │   │   ├── {{audio_categories}}
          │   ├── Art/
          │   │   ├── {{art_categories}}
          │   └── Resources/               # Runtime loaded assets
          ├── Packages/                    # Local UPM packages
          ├── Plugins/                     # Third-party plugins
          ├── StreamingAssets/             # Platform-deployed assets
          └── Editor/                      # Editor-only scripts and tools
          ```
      - id: organization-conventions
        title: Organization Conventions
        template: |
          **Naming Conventions:**
          - {{naming_rule_1}}
          - {{naming_rule_2}}
          - {{naming_rule_3}}

          **Asset Organization:**
          - {{organization_rule_1}}
          - {{organization_rule_2}}
          - {{organization_rule_3}}

          **Script Organization:**
          - {{script_organization_rule_1}}
          - {{script_organization_rule_2}}

  - id: unity-conventions
    title: Unity Development Conventions
    instruction: |
      Establish Unity-specific coding and development conventions adapted to the project:

      1. **Project-Adapted Conventions:**
         - Adapt conventions for 2D vs 3D development patterns
         - Consider starter template conventions if applicable
         - Align with target platform development requirements
         - Factor in team size and collaboration needs

      2. **Unity-Specific Patterns:**
         - MonoBehaviour lifecycle best practices
         - ScriptableObject usage guidelines optimized for project type
         - Prefab organization and naming conventions
         - Scene organization patterns for game architecture
         - Unity Events vs C# Events usage guidelines
         - Coroutine vs async/await decision framework

      Focus on Unity-specific patterns that complement general C# coding standards and support the architectural decisions made above.
    elicit: true
    sections:
      - id: component-patterns
        title: Component Design Patterns
        template: |
          **MonoBehaviour Guidelines:**
          - {{monobehaviour_guideline_1}}
          - {{monobehaviour_guideline_2}}
          - {{monobehaviour_guideline_3}}

          **Component Communication:**
          - {{communication_pattern_1}}
          - {{communication_pattern_2}}

          **Lifecycle Management:**
          - {{lifecycle_rule_1}}
          - {{lifecycle_rule_2}}
      - id: scriptableobject-patterns
        title: ScriptableObject Patterns
        template: |
          **Configuration Data:**
          - {{config_pattern_1}}
          - {{config_pattern_2}}

          **Runtime Data:**
          - {{runtime_pattern_1}}
          - {{runtime_pattern_2}}

          **Event Architecture:**
          - {{event_pattern_1}}
          - {{event_pattern_2}}

  - id: infrastructure-deployment
    title: Infrastructure and Deployment
    instruction: |
      Define Unity-specific build pipeline, deployment strategy, and infrastructure:

      1. **Unity Build Pipeline:**
         - Configuration for target platforms from tech stack
         - Build settings optimization for project type
         - Asset optimization and compression strategies
         - Platform-specific build variants and configurations

      2. **Unity Version Control:**
         - Unity-specific .gitignore configuration
         - Unity Cloud Build integration considerations
         - Large asset handling (Git LFS or alternatives)
         - Team collaboration workflow with Unity projects

      3. **Deployment Strategy:**
         - Platform-specific deployment pipelines
         - Unity Cloud Build or custom CI/CD integration
         - Automated testing pipeline with Unity Test Framework
         - Platform store deployment automation

      Consider Unity-native solutions and integration with general DevOps practices.
    elicit: true
    sections:
      - id: build-pipeline
        title: Build Pipeline
        template: |
          **Build Configurations:**
          - {{build_config_1}}
          - {{build_config_2}}

          **Platform Builds:**
          - {{platform_build_1}}
          - {{platform_build_2}}

          **Unity Optimization:**
          - {{unity_optimization_1}}
          - {{unity_optimization_2}}
      - id: version-control
        title: Version Control Setup
        template: |
          **Unity Project Configuration:**
          - {{unity_vcs_config_1}}
          - {{unity_vcs_config_2}}

          **Asset Management:**
          - {{asset_management_1}}
          - {{asset_management_2}}

          **Team Workflow:**
          - {{unity_workflow_rule_1}}
          - {{unity_workflow_rule_2}}

  - id: next-steps
    title: Next Steps
    instruction: |
      Outline the next phases of the architecture design process and what will be covered in subsequent templates.
    content: |
      This foundation architecture document establishes the core Unity setup and project structure optimized for {{project_name}}. The following architecture phases will build upon this Unity-native foundation:

      **Phase 2: Game Systems Architecture** (`game-architecture-systems-tmpl.yaml`)
      - Unity-specific gameplay systems and mechanics implementation
      - MonoBehaviour component architecture and ScriptableObject data models  
      - Unity Events and C# event system integration
      - Game state management with Unity's lifecycle

      **Phase 3: Platform Architecture** (`game-architecture-platform-tmpl.yaml`)  
      - Unity platform-specific optimizations and build configurations
      - Performance optimization strategies for Unity projects
      - Cross-platform compatibility with Unity's deployment pipeline
      - Unity Services integration and platform SDK configuration

      **Phase 4: Advanced Architecture** (`game-architecture-advanced-tmpl.yaml`)
      - Advanced Unity features integration (Addressables, Timeline, Cinemachine)
      - Unity Editor automation and custom tool development
      - Scalability patterns for large Unity projects  
      - Production deployment strategies and Unity Cloud services

      Each phase should be completed in sequence, with this foundation document serving as the basis for all subsequent Unity architectural decisions and maintaining consistency with the technology stack and patterns established here.