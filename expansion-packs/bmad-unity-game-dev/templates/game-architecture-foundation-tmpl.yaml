template:
  id: game-architecture-foundation-template-v1
  name: Game Architecture Foundation Document
  version: 1.0
  output:
    format: markdown
    filename: docs/game-architecture-foundation.md
    title: "{{project_name}} Game Architecture Foundation"

workflow:
  mode: interactive
  elicitation: advanced-elicitation

sections:
  - id: introduction
    title: Introduction
    instruction: |
      If available, review any provided relevant documents to gather all relevant context before beginning. At a minimum you should locate and review: Game Design Document (GDD), Technical Preferences. If these are not available, ask the user what docs will provide the basis for the game architecture.
    sections:
      - id: intro-content
        content: |
          This document outlines the foundational technical architecture for {{project_name}}, a {{ProjectDimension}} game built with Unity and C#. This is Part 1 of a multi-phase architecture design covering Unity setup, core infrastructure, and project organization.

          This foundation architecture is designed to support the gameplay mechanics defined in the Game Design Document while establishing solid technical groundwork for subsequent architectural phases.
      - id: starter-template
        title: Starter Template or Existing Project
        instruction: |
          Before proceeding further with game architecture design, check if the project is based on a Unity template or existing codebase:

          1. Review the GDD and brainstorming brief for any mentions of:
          - Unity templates (2D Core, 2D Mobile, 2D URP, etc.)
          - Existing Unity projects being used as a foundation
          - Asset Store packages or game development frameworks
          - Previous game projects to be cloned or adapted

          2. If a starter template or existing project is mentioned:
          - Ask the user to provide access via one of these methods:
            - Link to the Unity template documentation
            - Upload/attach the project files (for small projects)
            - Share a link to the project repository (GitHub, GitLab, etc.)
          - Analyze the starter/existing project to understand:
            - Pre-configured Unity version and render pipeline
            - Project structure and organization patterns
            - Built-in packages and dependencies
            - Existing architectural patterns and conventions
            - Any limitations or constraints imposed by the starter
          - Use this analysis to inform and align your architecture decisions

          3. If no starter template is mentioned but this is a greenfield project:
          - Suggest appropriate Unity templates based on the target platform
          - Explain the benefits (faster setup, best practices, package integration)
          - Let the user decide whether to use one

          4. If the user confirms no starter template will be used:
          - Proceed with architecture design from scratch
          - Note that manual setup will be required for all Unity configuration

          Document the decision here before proceeding with the architecture design. If none, just say N/A
        elicit: true
      - id: changelog
        title: Change Log
        type: table
        columns: [Date, Version, Description, Author]
        instruction: Track document versions and changes

  - id: high-level-architecture
    title: High Level Architecture
    instruction: |
      This section contains multiple subsections that establish the foundation of the game architecture. Present all subsections together at once.
    elicit: true
    sections:
      - id: technical-summary
        title: Technical Summary
        instruction: |
          Provide a brief paragraph (3-5 sentences) overview of:
          - The game's overall architecture style (component-based Unity architecture)
          - Key game systems and their relationships
          - Primary technology choices (Unity, C#, target platforms)
          - Core architectural patterns being used (MonoBehaviour components, ScriptableObjects, Unity Events)
          - Reference back to the GDD goals and how this architecture supports them
      - id: high-level-overview
        title: High Level Overview
        instruction: |
          Based on the GDD's Technical Assumptions section, describe:

          1. The main architectural style (component-based Unity architecture with MonoBehaviours)
          2. Repository structure decision from GDD (single Unity project vs multiple projects)
          3. Game system architecture (modular systems, manager singletons, data-driven design)
          4. Primary player interaction flow and core game loop
          5. Key architectural decisions and their rationale (render pipeline, input system, physics)
      - id: project-diagram
        title: High Level Project Diagram
        type: mermaid
        mermaid_type: graph
        instruction: |
          Create a Mermaid diagram that visualizes the high-level game architecture. Consider:
          - Core game systems (Input, Physics, Rendering, Audio, UI)
          - Game managers and their responsibilities
          - Data flow between systems
          - External integrations (platform services, analytics)
          - Player interaction points

      - id: architectural-patterns
        title: Architectural and Design Patterns
        instruction: |
          List the key high-level patterns that will guide the game architecture. For each pattern:

          1. Present 2-3 viable options if multiple exist
          2. Provide your recommendation with clear rationale
          3. Get user confirmation before finalizing
          4. These patterns should align with the GDD's technical assumptions and project goals

          Common Unity patterns to consider:
          - Component patterns (MonoBehaviour composition, ScriptableObject data)
          - Game management patterns (Singleton managers, Event systems, State machines)
          - Data patterns (ScriptableObject configuration, Save/Load systems)
          - Unity-specific patterns (Object pooling, Coroutines, Unity Events)
        template: "- **{{pattern_name}}:** {{pattern_description}} - _Rationale:_ {{rationale}}"
        examples:
          - "**Component-Based Architecture:** Using MonoBehaviour components for game logic - _Rationale:_ Aligns with Unity's design philosophy and enables reusable, testable game systems"
          - "**ScriptableObject Data:** Using ScriptableObjects for game configuration - _Rationale:_ Enables data-driven design and easy balancing without code changes"
          - "**Event-Driven Communication:** Using Unity Events and C# events for system decoupling - _Rationale:_ Supports modular architecture and easier testing"

  - id: tech-stack
    title: Tech Stack
    instruction: |
      This is the DEFINITIVE technology selection section for the Unity game. Work with the user to make specific choices:

      1. Review GDD technical assumptions and any preferences from {root}/data/technical-preferences.yaml or an attached technical-preferences
      2. For each category, present 2-3 viable options with pros/cons
      3. Make a clear recommendation based on project needs
      4. Get explicit user approval for each selection
      5. Document exact versions (avoid "latest" - pin specific versions)
      6. This table is the single source of truth - all other docs must reference these choices

      Key decisions to finalize - before displaying the table, ensure you are aware of or ask the user about:

      - Unity version and render pipeline
      - Target platforms and their specific requirements
      - Unity Package Manager packages and versions
      - Third-party assets or frameworks
      - Platform SDKs and services
      - Build and deployment tools

      Upon render of the table, ensure the user is aware of the importance of this sections choices, should also look for gaps or disagreements with anything, ask for any clarifications if something is unclear why its in the list, and also right away elicit feedback.
    elicit: true
    sections:
      - id: platform-infrastructure
        title: Platform Infrastructure
        template: |
          - **Target Platforms:** {{target_platforms}}
          - **Primary Platform:** {{primary_platform}}
          - **Platform Services:** {{platform_services_list}}
          - **Distribution:** {{distribution_channels}}
      - id: technology-stack-table
        title: Technology Stack Table
        type: table
        columns: [Category, Technology, Version, Purpose, Rationale]
        instruction: Populate the technology stack table with all relevant Unity technologies
        examples:
          - "| **Game Engine** | Unity | 2022.3.21f1 | Core game development platform | Latest LTS version, comprehensive package ecosystem |"
          - "| **Language** | C# | 10.0 | Primary scripting language | Unity's native language, strong typing, excellent tooling |"
          - "| **Render Pipeline** | Universal Render Pipeline (URP) | 14.0.10 | 2D/3D rendering | Optimized for mobile, excellent 2D features, future-proof |"
          - "| **Input System** | Unity Input System | 1.7.0 | Cross-platform input handling | Modern input system, supports multiple devices, rebindable controls |"
          - "| **Physics** | Unity 2D Physics | Built-in | 2D collision and physics | Integrated Box2D, optimized for 2D games |"
          - "| **Audio** | Unity Audio | Built-in | Audio playback and mixing | Built-in audio system with mixer support |"
          - "| **Testing** | Unity Test Framework | 1.1.33 | Unit and integration testing | Built-in testing framework based on NUnit |"

  - id: unity-project-structure
    title: Unity Project Structure
    instruction: |
      Define the complete Unity project folder structure and organization patterns:

      1. Review Unity best practices for project organization
      2. Consider the game's scale and complexity from the GDD
      3. Plan for team collaboration and asset management
      4. Include organization for scripts, prefabs, scenes, and data assets
      5. Consider platform-specific asset organization
      6. Plan for editor tools and development utilities

      Use Unity naming conventions and folder structures that scale with project growth.
    elicit: true
    sections:
      - id: folder-structure
        title: Project Folder Structure
        template: |
          ```
          Assets/
          ├── _Project/                    # Main project assets
          │   ├── Scripts/
          │   │   ├── {{script_categories}}
          │   ├── Prefabs/
          │   │   ├── {{prefab_categories}}
          │   ├── Scenes/
          │   │   ├── {{scene_categories}}
          │   ├── Data/
          │   │   ├── {{data_categories}}
          │   ├── Audio/
          │   │   ├── {{audio_categories}}
          │   ├── Art/
          │   │   ├── {{art_categories}}
          │   └── Resources/               # Runtime loaded assets
          ├── Plugins/                     # Third-party plugins
          ├── StreamingAssets/             # Platform-deployed assets
          └── Editor/                      # Editor-only scripts and tools
          ```
      - id: organization-conventions
        title: Organization Conventions
        template: |
          **Naming Conventions:**
          - {{naming_rule_1}}
          - {{naming_rule_2}}
          - {{naming_rule_3}}

          **Asset Organization:**
          - {{organization_rule_1}}
          - {{organization_rule_2}}
          - {{organization_rule_3}}

          **Script Organization:**
          - {{script_organization_rule_1}}
          - {{script_organization_rule_2}}

  - id: unity-conventions
    title: Unity Development Conventions
    instruction: |
      Establish Unity-specific coding and development conventions that the team will follow:

      1. Unity component design patterns (MonoBehaviour best practices)
      2. ScriptableObject usage guidelines
      3. Prefab organization and naming
      4. Scene organization patterns
      5. Unity Event vs C# Event usage
      6. Coroutine vs async/await guidelines
      7. Editor scripting conventions

      Focus on Unity-specific patterns that complement general C# coding standards.
    elicit: true
    sections:
      - id: component-patterns
        title: Component Design Patterns
        template: |
          **MonoBehaviour Guidelines:**
          - {{monobehaviour_guideline_1}}
          - {{monobehaviour_guideline_2}}
          - {{monobehaviour_guideline_3}}

          **Component Communication:**
          - {{communication_pattern_1}}
          - {{communication_pattern_2}}

          **Lifecycle Management:**
          - {{lifecycle_rule_1}}
          - {{lifecycle_rule_2}}
      - id: scriptableobject-patterns
        title: ScriptableObject Patterns
        template: |
          **Configuration Data:**
          - {{config_pattern_1}}
          - {{config_pattern_2}}

          **Runtime Data:**
          - {{runtime_pattern_1}}
          - {{runtime_pattern_2}}

          **Event Architecture:**
          - {{event_pattern_1}}
          - {{event_pattern_2}}

  - id: infrastructure-deployment
    title: Infrastructure and Deployment
    instruction: |
      Define the build pipeline, deployment strategy, and infrastructure requirements:

      1. Unity build pipeline configuration for target platforms
      2. Version control setup and Unity-specific considerations (.gitignore, LFS)
      3. Continuous integration setup for Unity projects
      4. Platform-specific build and deployment processes
      5. Testing pipeline integration
      6. Asset optimization and build size management

      Consider team workflow and automated deployment needs.
    elicit: true
    sections:
      - id: build-pipeline
        title: Build Pipeline
        template: |
          **Build Configurations:**
          - {{build_config_1}}
          - {{build_config_2}}

          **Platform Builds:**
          - {{platform_build_1}}
          - {{platform_build_2}}

          **Build Optimization:**
          - {{optimization_1}}
          - {{optimization_2}}
      - id: version-control
        title: Version Control Setup
        template: |
          **Repository Configuration:**
          - {{repo_config_1}}
          - {{repo_config_2}}

          **Unity-Specific Settings:**
          - {{unity_vcs_setting_1}}
          - {{unity_vcs_setting_2}}

          **Team Workflow:**
          - {{workflow_rule_1}}
          - {{workflow_rule_2}}

  - id: next-steps
    title: Next Steps
    instruction: |
      Outline the next phases of the architecture design process and what will be covered in subsequent templates.
    content: |
      This foundation architecture document establishes the core Unity setup and project structure. The following architecture phases will build upon this foundation:

      **Phase 2: Game Systems Architecture**
      - Core gameplay systems and mechanics
      - Data models and game state management
      - Component architecture and interactions

      **Phase 3: Platform Architecture**
      - Platform-specific implementations
      - Performance optimization strategies
      - Cross-platform compatibility

      **Phase 4: Advanced Architecture**
      - Advanced Unity features and integrations
      - Scalability and maintenance considerations
      - Production deployment strategies

      Each phase should be completed in sequence, with this foundation document serving as the basis for all subsequent architectural decisions.